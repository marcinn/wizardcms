--- mptt/managers.py	2008-12-05 00:17:36 +0000
+++ mptt/managers.py	2008-12-05 01:37:34 +0000
@@ -208,6 +208,83 @@
         """
         return self.filter(**{'%s__isnull' % self.parent_attr: True})
 
+    def rebuild(self):
+        """
+        Rebuilds whole tree in database using `parent` link.
+        """
+        opts = self.model._meta
+        
+        cursor = connection.cursor()
+        cursor.execute('UPDATE %(table)s SET %(left)s = 0, %(right)s = 0, %(level)s = 0, %(tree_id)s = 0' % {
+            'table': qn(opts.db_table),
+            'left': qn(opts.get_field(self.left_attr).column),
+            'right': qn(opts.get_field(self.right_attr).column),
+            'level': qn(opts.get_field(self.level_attr).column),
+            'tree_id': qn(opts.get_field(self.tree_id_attr).column)
+        })
+        
+        if opts.order_insertion_by:
+            temp_order_by = 'ORDER BY ' + ', '.join([qn(field) for field in opts.order_insertion_by])
+        else:
+            temp_order_by = ''
+        cursor.execute('SELECT %(id_col)s FROM %(table)s WHERE %(parent_col)s is NULL %(orderby)s' % {
+            'id_col': qn(opts.pk.column),
+            'table': qn(opts.db_table),
+            'parent_col': qn(opts.get_field(self.parent_attr).column),
+            'orderby': temp_order_by
+        })
+
+        idx = 0
+        for (pk, ) in cursor.fetchall():
+            idx += 1
+            self._rebuild_helper(pk, 1, idx)
+        transaction.commit_unless_managed()
+
+    def _rebuild_helper(self, pk, left, tree_id, level=0):
+        opts = self.model._meta
+        right = left + 1
+
+        if opts.order_insertion_by:
+            temp_order_by = 'ORDER BY ' + ', '.join([qn(field) for field in opts.order_insertion_by])
+        else:
+            temp_order_by = ''
+        cursor = connection.cursor()
+        cursor.execute('SELECT %(id_col)s FROM %(table)s WHERE %(parent_col)s = %(parent)d %(orderby)s' % {
+            'id_col': qn(opts.pk.column),
+            'table': qn(opts.db_table),
+            'parent_col': qn(opts.get_field(self.parent_attr).column),
+            'parent': pk,
+            'orderby': temp_order_by
+        })
+        
+        for (child_id, ) in cursor.fetchall():
+            right = self._rebuild_helper(child_id, right, tree_id, level+1)
+        
+        cursor.execute("""
+            UPDATE %(table)s
+            SET
+                %(left_col)s = %(left)d,
+                %(right_col)s = %(right)d,
+                %(level_col)s = %(level)d,
+                %(tree_id_col)s = %(tree_id)d
+            WHERE
+                %(pk_col)s = %(pk)s
+        """ % {
+            'table': qn(opts.db_table),
+            'pk_col': qn(opts.pk.column),
+            'left_col': qn(opts.get_field(self.left_attr).column),
+            'right_col': qn(opts.get_field(self.right_attr).column),
+            'level_col': qn(opts.get_field(self.level_attr).column),
+            'tree_id_col': qn(opts.get_field(self.tree_id_attr).column),
+            'pk': pk,
+            'left': left,
+            'right': right,
+            'level': level,
+            'tree_id': tree_id
+        })
+        
+        return right + 1
+            
     def _calculate_inter_tree_move_values(self, node, target, position):
         """
         Calculates values required when moving ``node`` relative to

